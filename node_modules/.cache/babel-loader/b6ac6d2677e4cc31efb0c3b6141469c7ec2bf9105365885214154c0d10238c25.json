{"ast":null,"code":"// /src/services/api.js\nexport const API_URL=\"https://gymsmart.azurewebsites.net/api\";// Evita que múltiples peticiones hagan refresh simultáneamente\nlet isRefreshing=false;// Cola de peticiones que esperan a que termine el refresh\nlet refreshSubscribers=[];/**\n * Llama al endpoint /api/Auth/refresh para obtener un nuevo token.\n * Requiere que guardes `refreshToken` y `token` en localStorage.\n */async function refreshSession(){isRefreshing=true;try{const oldToken=localStorage.getItem(\"token\");const refreshToken=localStorage.getItem(\"refreshToken\");if(!oldToken||!refreshToken){throw new Error(\"No hay token o refreshToken en localStorage.\");}const response=await fetch(`${API_URL}/Auth/refresh`,{method:\"POST\",headers:{\"Content-Type\":\"application/json\",Authorization:`Bearer ${oldToken}`// enviamos el token antiguo\n},body:JSON.stringify({refreshToken})});if(!response.ok){throw new Error(\"Error al refrescar el token\");}const data=await response.json();// Guardar el nuevo token y refreshToken\nlocalStorage.setItem(\"token\",data.token);localStorage.setItem(\"refreshToken\",data.refreshToken);// Notificamos a las peticiones en cola que ya tenemos nuevo token\nrefreshSubscribers.forEach(callback=>callback(data.token));refreshSubscribers=[];return data.token;}finally{isRefreshing=false;}}/**\n * Realiza una petición a la API con fetch y maneja automáticamente\n * el refresh del token si recibimos un 401 (Unauthorized).\n *\n * @param {string} endpoint - Ruta de la API (ej: \"usuarios\")\n * @param {string} [method=\"GET\"] - Método HTTP (GET, POST, PUT, DELETE)\n * @param {Object} [body=null] - Datos a enviar en el body\n * @param {boolean} [reintento=false] - Para evitar bucles infinitos de refresh\n * @returns {Promise<any>} - Respuesta en formato JSON\n */export const apiRequest=async function(endpoint){let method=arguments.length>1&&arguments[1]!==undefined?arguments[1]:\"GET\";let body=arguments.length>2&&arguments[2]!==undefined?arguments[2]:null;let reintento=arguments.length>3&&arguments[3]!==undefined?arguments[3]:false;const token=localStorage.getItem(\"token\");let headers={\"Content-Type\":\"application/json\"};if(token){headers.Authorization=`Bearer ${token}`;}let options={method,headers};if(body){options.body=JSON.stringify(body);}// Hacemos la petición\nconst response=await fetch(`${API_URL}/${endpoint}`,options);// Si el token expiró y no hemos reintentado todavía, hacemos refresh\nif(response.status===401&&!reintento){// Si ya se está refrescando, esperamos a que termine\nif(isRefreshing){// Devolvemos una promesa que se resuelve cuando se complete el refresh\nreturn new Promise((resolve,reject)=>{refreshSubscribers.push(async newToken=>{try{const newHeaders={...headers,Authorization:`Bearer ${newToken}`};const newResponse=await fetch(`${API_URL}/${endpoint}`,{...options,headers:newHeaders});if(!newResponse.ok){throw new Error(\"Error tras refrescar token\");}const result=await newResponse.json();resolve(result);}catch(error){reject(error);}});});}else{// Hacemos refresh de token directamente\ntry{const newToken=await refreshSession();const newHeaders={...headers,Authorization:`Bearer ${newToken}`};const newResponse=await fetch(`${API_URL}/${endpoint}`,{...options,headers:newHeaders});if(!newResponse.ok){throw new Error(\"Error tras refrescar token\");}return newResponse.json();}catch(error){throw error;}}}// Si la respuesta es distinta de 401 o ya reintentamos, lanzamos error si no es OK\nif(!response.ok){throw new Error(\"Error en la petición: \"+response.status);}// Si todo va bien, devolvemos el JSON\nreturn response.json();};","map":{"version":3,"names":["API_URL","isRefreshing","refreshSubscribers","refreshSession","oldToken","localStorage","getItem","refreshToken","Error","response","fetch","method","headers","Authorization","body","JSON","stringify","ok","data","json","setItem","token","forEach","callback","apiRequest","endpoint","arguments","length","undefined","reintento","options","status","Promise","resolve","reject","push","newToken","newHeaders","newResponse","result","error"],"sources":["/Users/fernandovargas/Documents/GitHub/gymfront/src/services/api.js"],"sourcesContent":["// /src/services/api.js\n\nexport const API_URL = \"https://gymsmart.azurewebsites.net/api\";\n\n// Evita que múltiples peticiones hagan refresh simultáneamente\nlet isRefreshing = false;\n\n// Cola de peticiones que esperan a que termine el refresh\nlet refreshSubscribers = [];\n\n/**\n * Llama al endpoint /api/Auth/refresh para obtener un nuevo token.\n * Requiere que guardes `refreshToken` y `token` en localStorage.\n */\nasync function refreshSession() {\n  isRefreshing = true;\n\n  try {\n    const oldToken = localStorage.getItem(\"token\");\n    const refreshToken = localStorage.getItem(\"refreshToken\");\n    if (!oldToken || !refreshToken) {\n      throw new Error(\"No hay token o refreshToken en localStorage.\");\n    }\n\n    const response = await fetch(`${API_URL}/Auth/refresh`, {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n        Authorization: `Bearer ${oldToken}`, // enviamos el token antiguo\n      },\n      body: JSON.stringify({ refreshToken }),\n    });\n\n    if (!response.ok) {\n      throw new Error(\"Error al refrescar el token\");\n    }\n\n    const data = await response.json();\n    // Guardar el nuevo token y refreshToken\n    localStorage.setItem(\"token\", data.token);\n    localStorage.setItem(\"refreshToken\", data.refreshToken);\n\n    // Notificamos a las peticiones en cola que ya tenemos nuevo token\n    refreshSubscribers.forEach((callback) => callback(data.token));\n    refreshSubscribers = [];\n\n    return data.token;\n  } finally {\n    isRefreshing = false;\n  }\n}\n\n/**\n * Realiza una petición a la API con fetch y maneja automáticamente\n * el refresh del token si recibimos un 401 (Unauthorized).\n *\n * @param {string} endpoint - Ruta de la API (ej: \"usuarios\")\n * @param {string} [method=\"GET\"] - Método HTTP (GET, POST, PUT, DELETE)\n * @param {Object} [body=null] - Datos a enviar en el body\n * @param {boolean} [reintento=false] - Para evitar bucles infinitos de refresh\n * @returns {Promise<any>} - Respuesta en formato JSON\n */\nexport const apiRequest = async (endpoint, method = \"GET\", body = null, reintento = false) => {\n  const token = localStorage.getItem(\"token\");\n\n  let headers = {\n    \"Content-Type\": \"application/json\",\n  };\n\n  if (token) {\n    headers.Authorization = `Bearer ${token}`;\n  }\n\n  let options = {\n    method,\n    headers,\n  };\n\n  if (body) {\n    options.body = JSON.stringify(body);\n  }\n\n  // Hacemos la petición\n  const response = await fetch(`${API_URL}/${endpoint}`, options);\n\n  // Si el token expiró y no hemos reintentado todavía, hacemos refresh\n  if (response.status === 401 && !reintento) {\n    // Si ya se está refrescando, esperamos a que termine\n    if (isRefreshing) {\n      // Devolvemos una promesa que se resuelve cuando se complete el refresh\n      return new Promise((resolve, reject) => {\n        refreshSubscribers.push(async (newToken) => {\n          try {\n            const newHeaders = {\n              ...headers,\n              Authorization: `Bearer ${newToken}`,\n            };\n            const newResponse = await fetch(`${API_URL}/${endpoint}`, {\n              ...options,\n              headers: newHeaders,\n            });\n            if (!newResponse.ok) {\n              throw new Error(\"Error tras refrescar token\");\n            }\n            const result = await newResponse.json();\n            resolve(result);\n          } catch (error) {\n            reject(error);\n          }\n        });\n      });\n    } else {\n      // Hacemos refresh de token directamente\n      try {\n        const newToken = await refreshSession();\n        const newHeaders = {\n          ...headers,\n          Authorization: `Bearer ${newToken}`,\n        };\n        const newResponse = await fetch(`${API_URL}/${endpoint}`, {\n          ...options,\n          headers: newHeaders,\n        });\n        if (!newResponse.ok) {\n          throw new Error(\"Error tras refrescar token\");\n        }\n        return newResponse.json();\n      } catch (error) {\n        throw error;\n      }\n    }\n  }\n\n  // Si la respuesta es distinta de 401 o ya reintentamos, lanzamos error si no es OK\n  if (!response.ok) {\n    throw new Error(\"Error en la petición: \" + response.status);\n  }\n\n  // Si todo va bien, devolvemos el JSON\n  return response.json();\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}